# svgs-to-icons

![Node.js CLI](https://img.shields.io/badge/CLI-Node.js-green)
![Node Version](https://img.shields.io/badge/node-%3E%3D18.0.0-brightgreen)
![License](https://img.shields.io/badge/license-MIT-blue)

**A command-line tool that converts SVG files into easy-to-use CSS icon classes.**

![Screenshot of svgs-to-icons demo](svgs-to-icons.png)

```bash
# Quick start
npm install -g svgs-to-icons
svgs-to-icons ./path/to/svg-folder
```

`svgs-to-icons` takes a folder of SVGs and generates:

- **Optimized SVG files** with consistent, class-safe names
- **CSS classes** that render those icons using `mask-image`, allowing them to be colorized with `currentColor`
- **Two versions of the CSS:**
  - **Embedded**: SVGs are inlined using `data:` URIs
  - **File-referenced**: SVGs are linked via `url("icon.svg")`
- **Demo HTML pages** for each version so you can preview the output

This gives you a modern, minimal, and scalable icon system that can be used in any HTML or CSS setup — no JS required.

This will be a good icon solution for you if:

- You have a directory full of SVG files you’d like to use as icons.
- You don’t want to install a JavaScript component library just to render icons.
- You don’t want to download an icon font.
- You’re looking for a solution that integrates seamlessly with vanilla HTML and CSS.
- You want to be able to use colorized icons in line with text.

Not sure if `svgs-to-icons` is a good fit for your use case? Read on, or skip to [Alternatives for Rendering Icons](#alternatives-for-rendering-icons).

## How to Use `svgs-to-icons`

### 0. Installation

**From NPM (Recommended):**
```bash
# Install globally
npm install -g svgs-to-icons

# Or use with npx (no installation required)
npx svgs-to-icons ./my-icons
```

### 1. Create or gather a set of SVG icons in a folder:

```
./my-icons/
├── home.svg
├── user.svg
└── settings.svg
```

### 2. Run `svgs-to-icons`:

```bash
svgs-to-icons ./my-icons
# or (if not globally installed)
npx svgs-to-icons ./my-icons
```

### 3. `svgs-to-icons` will:

- Optimize and sanitize the SVGs
- Rename them to class-safe names (i.e., no leading numerals, special characters, etc.) — see [CSS Class Name Collisions](#css-class-name-collisions).
- Generate output in the default `dist/` directory:

```
dist/my-icons/
├── embedded-icons/
│   ├── icons.css
│   └── index.html (demo)
└── referenced-icons/
    ├── icons (directory of SVGs)
    ├── icons.css
    └── index.html (demo)
```

Note: Both embedded and referenced versions are generated by default, along with interactive demo pages in index.html. Embedded icons are contained in the css file itself — you just need to import `icons.css`. Referenced icons require both `icons.css` and the `icons` directory of SVGs.

### 4. Preview the results:

Upon completion, the script will output a direct link to the `embedded-icons/index.html` page. In most modern terminals, you can Command-click (macOS) or Control-click (Windows/Linux) this link to open it directly in your default web browser. While you can view this file by opening it directly in a web browser, viewing the referenced icons requires a server.

### 5. Use the icons in your HTML:

```html
<!-- Include the CSS file -->
<link rel="stylesheet" href="dist/my-icons/embedded-icons/icons.css">

<!-- Use the icons (note the default -icon postfix) -->
<span class="home-icon"></span>
```

### 6. Style with CSS:

Use `font-size` and `color`, as for text styling.

```css
.home-icon {
  font-size: 1.25rem;
  color: #444;
}
```

### 7. Test in your environment:

Before deploying, verify that all icons display correctly in your target environment and check for any CSS class name conflicts. The generated CSS uses wildcard selectors like `[class*="-icon"]` to apply base styles, which can potentially affect existing classes in your project that contain the same patterns.

If you encounter conflicts, use the `--prefix` and `--postfix` options to create more distinctive class names (e.g., `--prefix "svg-"` or `--postfix "-svg"`).

## Try out the example icons

The repository includes a sample icon set in the `examples/chair-icons/` directory. Use this to test the tool:

```bash
svgs-to-icons ./examples/chair-icons
```

This processes 9 chair-themed icons from various icon libraries, demonstrating how the tool handles different SVG sources and naming conventions.

## FAQ

### Quick Links
- [What’s the difference between embedded and file-referenced CSS?](#whats-the-difference-between-embedded-and-file-referenced-css)
- [Why do I need a server for file-referenced icons?](#why-do-i-need-a-server-for-file-referenced-icons)
- [I can’t see the icons. What should I do?](#i-cant-see-the-icons-what-should-i-do)
- [How are the icons optimized?](#how-are-the-icons-optimized)
- [Why do you rename the icons?](#why-do-you-rename-the-icons)
- [Can I use `<i>` tags for icons?](#can-i-use-i-tags-for-icons)
- [Do these icons support color?](#do-these-icons-support-color)
- [Can I use this for emojis?](#can-i-use-this-for-emojis)
- [What’s the difference between svgs-to-icons’s approach and React/Vue icon components?](#whats-the-difference-between-svgs-to-iconss-approach-and-reactvue-icon-components)

### What’s the difference between embedded and file-referenced CSS?

- **Embedded** icons are inlined into the CSS as data URIs. This makes your CSS self-contained and avoids HTTP requests — ideal for a small set of icons that are always needed. You can preview this version directly in a browser from your local file system.
- **File-referenced** icons are linked by `url(\"...\")` in CSS. This keeps your CSS smaller and lets browsers cache the icons separately. It’s better for larger sets or when icons are reused across pages.
  - To preview this version locally, you’ll need to use a simple HTTP server. 
  - The urls in the CSS are set up with relative references to the SVG files in the icons directory. If you move the directory elsewhere, you’ll need to update the URLs in the CSS file.
  - If hosting SVGs on a different domain than your HTML, ensure proper CORS configuration on the SVG server (see FAQ below).

`svgs-to-icons` generates embedded CSS icons and referenced icons; the CSS class names and visual presentation are identical for both.

### Why do I need a server for file-referenced icons?

When you open an HTML file directly from your local file system (using a `file:///` path), browsers impose strict security restrictions. These prevent the HTML page from loading other local files, such as the individual SVG files linked by the `referenced-icons` CSS. If you want to view this file locally, your operating system may have software to launch a web server; check your documentation or Google. If you have `node` installed, you can navigate to the output directory where the `index.html` for the referenced icons is located (e.g., `cd ./dist/my-icons/referenced-icons/`), and run the following command:

```bash
npx serve .
```

This will download `serve` if not already present and start a server.

Alternately, Mac users can navigate to the referenced icon folder and run the following command to start a server:

```bash
python3 -m http.server 8000 
```

### I can’t see the icons. What should I do?

**If you’re using the embedded icon CSS:**
* Make sure that your code is correctly loading the icon CSS with a `<link>` tag.
* If you’ve cut and pasted icons from the original output file and put them into a new CSS file, be sure to include the base code at the beginning of the file that is essential for icon display.
* Be sure to assign a color to your icons that will make them visible against their background.

**If you’re using the referenced icon CSS:**
- Make sure you’re using a webserver to serve, as mentioned in the [preceding FAQ](#why-do-i-need-a-server-for-file-referenced-icons).
- Make sure that your webserver has CORS permissions set correctly (see [CORS Configuration](#cors-configuration)).
- If you’ve moved or renamed the `referenced-icons/icons` directory, you’ll need to make sure that the icon paths in `icons.css` are updated correctly.

### How are the icons optimized?

`svgs-to-icons` uses [`svgo`](https://github.com/svg/svgo) to:
- Remove metadata
- Minimize path and group complexity
- Strip unnecessary attributes

For embedded icons, we additionally minify them into data URIs using [`mini-svg-data-uri`](https://github.com/tigt/mini-svg-data-uri).

### Why do you rename the icons?

Icon file names often contain characters that don’t work well in CSS class names. `svgs-to-icons`:
- Converts names to lowercase and replaces invalid characters with hyphens
- Removes special characters and normalizes spacing
- Prefixes numeric filenames with “i” (e.g., `123.svg` → `.i123-icon`)
- Ensures valid, predictable class names
Note that the icon names are also used for the names of the corresponding SVG files in the `icons`  directory

### Can I use `<i>` tags for icons?

You can, but you shouldn’t. `<i>` is a semantic tag for italics, and using it for icons is bad practice for accessibility and maintainability. Use `<span>` or `<div>` with appropriate ARIA roles or labels if needed.

### Do these icons support color?

They are fully **colorizable** using `color` on the icon or a parent element. These icons **do not support** multiple colors within the same shape. They’re single-shape, single-color icons — just like the icons rendered by icon fonts.

### Can I use this for emojis?

Probably not. Emojis are typically multicolor graphics. `svgs-to-icons` uses CSS masks, which cannot display multiple colors within a single icon.

If you need accessible emoji-style icons, consider using:
- [Twemoji](https://twemoji.twitter.com/)
- [Noto Emoji](https://github.com/googlefonts/noto-emoji)

### What’s the difference between `svgs-to-icons`’s approach and React/Vue icon components?

`svgs-to-icons` supports two common ways of displaying icons with CSS: embedded data URIs and SVG file references. These are compatible with any HTML code (including that generated by frameworks) and do not require Javascript. Most framework components inject SVG markup directly into the HTML instead, either at runtime (using Javascript) or via a build process. Component libraries are certainly convenient, especially when built into UI frameworks like shadcn, Vuetify, Material Design, etc., but it may be more difficult to use custom icons with these frameworks.

## CLI Options

### Basic Usage
```bash
svgs-to-icons <input-directory> [options]
```

### Default Behavior

Without any options, `svgs-to-icons` will:
- Create output in a `dist/` directory (relative to where you run the command)
- Generate **both** embedded and referenced icon versions
- Include interactive demo HTML pages for both versions
- Use `-icon` as the default postfix for CSS class names

```bash
# This command:
svgs-to-icons ./my-icons

# Creates this structure:
dist/my-icons/
├── embedded-icons/
│   ├── icons.css
│   └── index.html (demo)
└── referenced-icons/
    ├── icons/
    ├── icons.css
    └── index.html (demo)
```

### Available Options

| Option | Description | Default | Example |
|--------|-------------|---------|------|
| `--output <dir>` | Parent directory for output files | `dist` | `--output ./build` |
| `--prefix <string>` | Prefix for CSS class names | *(none)* | `--prefix ui` |
| `--postfix <string>` | Postfix for CSS class names | `-icon` | `--postfix btn` |
| `--embedded` | Generate only embedded icons (data URIs) | *both versions* | `--embedded` |
| `--referenced` | Generate only referenced icons (file paths) | *both versions* | `--referenced` |
| `--demo` | Generate interactive demo HTML files | `true` | `--demo false` |

### Prefix and Postfix Details
When not specified, all of your icon classes will have the default postfix of `-icon`.  You can change/remove the postfix and add a prefix using the CLI options described below. You are required to have a prefix *or* a postfix; you can optionally have both. They’re used to apply CSS properties to all of your icons.

**Automatic Hyphen Handling:**
- **Prefix:** If your prefix doesn’t end with a hyphen, one is automatically added
  - `--prefix ui` becomes `ui-` → `.ui-home-icon`
  - `--prefix nav-` stays `nav-` → `.nav-home-icon`
  
- **Postfix:** If your postfix doesn’t start with a hyphen, one is automatically added
  - `--postfix btn` becomes `-btn` → `.home-btn`
  - `--postfix -icon` stays `-icon` → `.home-icon`

**Examples:**
```bash
# Creates classes like .ui-home-btn
svgs-to-icons ./icons --prefix ui --postfix btn

# Creates classes like .nav-home-icon  
svgs-to-icons ./icons --prefix nav- --postfix -icon

# Creates classes like .btn-home
svgs-to-icons ./icons --prefix btn --postfix ""
```

### Output Directory
You can specify an output directory using the `--output` parameter. If you do not specify an output directory, the processed files will be placed in the `dist` directory.

**Example:**
```bash
# Generate output at root
svgs-to-icons --output .
```

### Embedded and Referenced CSS Files, Demo Files

By default, `svgs-to-icons` generates both embedded and referenced versions with demo files. You can control this:

```bash
# Generate only embedded icons
svgs-to-icons ./icons --embedded

# Generate only referenced icons  
svgs-to-icons ./icons --referenced

# Skip demo files
svgs-to-icons ./icons --demo false
```

## Technical Details

### Generated CSS Structure

The CSS that `svgs-to-icons` generates consists of two parts that work together:

#### 1. Base Styles (Applied to All Icons)

```css
[class*="-icon"] {
    mask-size: 100% 100%;
    background-color: currentColor;
    mask-repeat: no-repeat;
    mask-position: center;
    height: 1em;
    width: 1em;
    display: inline-block;
}
```

The wildcard selector `[class*="-icon"]` matches any class containing “-icon” and applies the `mask` properties that all icons need.

#### 2. Individual Icon Rules

The second part of the CSS is the set of classes associated with the icons themselves; this code differs in the embedded and referenced versions:

**Embedded Icons** (using data URIs):

```css
.home-icon { mask-image:url("data:image/svg+xml,<optimized-svg>"); }
.settings-icon { mask-image:url("data :image/svg+xml,<optimized-svg>"); }
```

**Referenced Icons** (using relative file paths):

```css
.home-icon { mask-image:url("./icons/home.svg"); }
.settings-icon { mask-image:url("./icons/settings.svg"); }
```

The relative paths (./icons/) used by default within` icons.css` assumes that the file and the `icons` directory are in the same folder:

```text
your-project/
├── icons.css
└── icons/
    ├── home.svg
    └── settings.svg
```
If you move the SVG files to a different location, you'll need to update the paths in your CSS. For example, if you move the icons to an assets directory:

```text
your-project/
├── icons.css
└── assets/
    └── icons/
        ├── home.svg
        └── settings.svg
```

You’ll need to update your CSS from:
```css
.home-icon { mask-image:url("./icons/home.svg"); }```
```
to:
```css
.home-icon { mask-image:url("./assets/icons/home.svg"); }```
```

(You can of course use find and replace to update all instances of `./icons/` to `./assets/icons/` throughout `icons.css`.)

### Styling Icons as Fonts
Users who are familiar with icon fonts, such as FontAwesome, will be accustomed to sizing and colorizing their icons with the CSS properties used for fonts. We’ve accommodated this practice in the base icon styles. By setting the icons to a `width` and `height` of `1em`, applying `font-size: 20px` will render an icon in a 20px block. By setting `background-color: currentColor`, the icons can be colorized with the text color property. And as icons are often used inline with other text, we’re using `display: inline-block`.

### CSS Class Name Collisions
Different SVG filenames may generate identical base class names after sanitization. For example, `Home.svg`, `HOME.svg`, and `home@.svg` all become `home` after processing.

**Automatic collision handling:** `svgs-to-icons` automatically resolves collisions by adding numeric suffixes to the base name (shown here with default `-icon` postfix):
- First occurrence: `home` → `.home-icon`
- Second occurrence: `home-1` → `.home-1-icon` 
- Third occurrence: `home-2` → `.home-2-icon`

**Special case:** Files with names that result in empty or invalid class names (like `.svg`, `@.svg`, `!#$.svg`) become `unnamed`, `unnamed-1`, `unnamed-2`, etc. (before prefix/postfix are applied).

**Best practices** (to avoid numbered suffixes):
- Use consistent, unique filenames 
- Avoid special characters, spaces, and mixed case in filenames
- Consider using descriptive prefixes (e.g., `ui-home.svg`, `nav-home.svg`)
- Ensure filenames contain at least one alphanumeric character

### Prefixes and Postfixes

By default, `svgs-to-icons` generates class names with an `-icon` postfix. For example, `home.svg` becomes `.home-icon` and `settings.svg` becomes `.settings-icon`.

You can customize this behavior using the `--prefix` and `--postfix` options to create class names that match your project's naming conventions.

**Wildcard Selector Considerations:**
The generated CSS uses wildcard selectors to apply base styles to all icons. With the default `-icon` postfix, the CSS includes `[class*="-icon"]` which will match any class containing “-icon” anywhere in the name, including classes like `.navigation-icon-wrapper` or `.my-section-icon-container`.

To avoid conflicts, choose distinctive prefixes and postfixes that are unlikely to appear in your existing class names, such as `--prefix "svg-"` or `--postfix "-svg"`.

### CORS Configuration

CORS (Cross-Origin Resource Sharing) is a browser security feature that controls how web pages from one domain can request resources from another domain. Without the correct CORS headers, browsers will block the requests for cross-origin SVGs, and file-referenced icons will not appear. (The embedded icon CSS does not have this issue.)

If you host your website on `https://www.example.com` and host your SVG icon files on a separate domain (or subdomain), like `https://cdn.example-icons.com`, the browser will block your CSS (from `www.example.com`) from loading the SVG files (from `cdn.example-icons.com`) unless the server at `cdn.example-icons.com` explicitly allows it.

To enable this, the server hosting the SVG files must include the `Access-Control-Allow-Origin` HTTP header in its responses. For example:
`Access-Control-Allow-Origin: https://www.example.com` (to allow only your website)
OR
`Access-Control-Allow-Origin: *` (to allow any website, use with caution)

For information on how to enable CORS on different server platforms, see [I want to add CORS support to my server](https://enable-cors.org/server.html) at enable-cors.org.


### Color Palette in the Demo files

The interactive demo pages use a customizable color system defined in `templates/colors.js`. This provides the color options in the “Icon Color” and “Background Color” dropdowns.

**Default colors include:**
- Base colors: Blue, Green, Red, Yellow, Orange, Purple, Teal
- Each color family has lighten/darken variants (e.g., `blue-lighten-10`, `blue-darken-20`)
- Extended grayscale options
- Common colors: Black, White, Transparent

**To customize the color palette:**
1. Edit `templates/colors.js`
2. Follow the existing data format:
   ```javascript
   'color-name': { value: '#HEX-CODE', name: 'Display Name' }
   ```
3. Regenerate your icons to see the new colors in demo pages

The color system is well-documented within the file itself, including structure guidelines and usage examples.


### Dependencies

- `svgo`: SVG optimization,[svgo on NPM](https://www.npmjs.com/package/svgo)
- `mini-svg-data-uri`: Efficient data URI encoding, [mini-svg-data-uri on NPM](https://www.npmjs.com/package/mini-svg-data-uri)
- `commander`: Command-line interface framework, [commander on NPM](https://www.npmjs.com/package/commander)
- Node.js built-in modules: `fs`, `path`

### Browser Compatibility

**Icon CSS Files (CSS Masking):**
The generated icon CSS uses the standard `mask-image` property, which is supported in all modern browsers. **Internet Explorer has no support for CSS masking** and icons will not display at all.

For older Safari versions (Safari 4-15.3) that require `-webkit-` prefixes, see the code comments in `svgs-to-icons-core.js` for modification instructions.

**Demo Pages:**
The interactive demo pages use modern CSS features and require recent browsers (Chrome 112+, Firefox 117+, Safari 16.5+). These demos are for development convenience only and do not affect the functionality of the generated icon CSS.

## Alternatives for Rendering Icons

You have a number of options for rendering icons in HTML; each has its pros and cons. Here are a few commonly-used systems.

### FontAwesome
[FontAwesome](https://fontawesome.com/) arguably started a revolution in 2012 by making large sets of professionally designed icons available on the web through a single font file. Its early approach — rendering icons via font glyphs — allowed developers to scale and style icons using familiar CSS properties like `font-size` and `color`. In more recent versions, FontAwesome has transitioned to an SVG-based model, offering component libraries for Vue, React, and Angular, as well as a script-based solution for injecting icons at runtime.
FontAwesome’s tools are reliable and well-integrated with modern JavaScript frameworks, but they work exclusively with the FontAwesome icon sets. Custom icons can be added, but only by converting them into a proprietary format and manually registering them. Compared to `svgs-to-icons`, FontAwesome is more powerful in dynamic app settings but far less flexible for quickly converting and using arbitrary SVGs — especially in CSS-only or HTML-first workflows.
—
### Iconify
[Iconify](https://iconify.design/) offers access to over 200,000 icons across a wide variety of public icon sets, many of them from commonly-used design systems. It supports multiple rendering strategies: icons can be injected into the DOM via framework components (Vue, React), rendered via a custom web component, inlined at build time using Vite or Webpack plugins, even simply cut-and-pasted as CSS from their site. This versatility allows developers to choose between runtime flexibility and build-time performance.
Iconify also supports custom icon sets, but doing so typically requires adopting their internal JSON format or configuring file system loaders for build-time integration. In comparison, `svgs-to-icons` handles custom icons much more directly — just point it at a folder of SVGs and it generates optimized CSS with no configuration. Where Iconify excels is in scale and dynamic integration; where it falls short is in simplicity and plug-and-play support for custom assets.
—
### UnoCSS Icons
Anthony Fu’s [UnoCSS](https://unocss.dev/) is an engine for CSS utility classes — it’s similar to Bootstrap, Tailwind and other CSS frameworks, but it can allow you to mix and match from different frameworks, compiling only the CSS you need at build time. UnoCSS Icons is a plugin that allows you to use icons as utility classes — for example, `i-mdi-home` — and inlines their SVGs using `mask-image`, much like `svgs-to-icons`. Through standard naming conventions, it provides easy access to the entire Iconify library.
Both UnoCSS Icons and `svgs-to-icons` generate CSS-based icon styles with no runtime JavaScript and support styling via `color` and `font-size`. Where they differ is in setup and scope: UnoCSS is a CSS framework with a build routine that runs whenever you change your CSS; `svgs-to-icons` works independently of any CSS methodology and only needs to generate icon assets when your icon SVGs change. Additionally, while UnoCSS supports custom icons via configuration, `svgs-to-icons` requires no plugin setup or registration — it simply processes any folder of SVGs directly.
—
### IcoMoon
[IcoMoon](https://icomoon.io/) is a GUI-based online tool for creating custom icon fonts or SVG sprite sheets. It allows users to upload SVGs, combine them into a set, and export them as web fonts or inline SVG bundles. IcoMoon was a common choice in the era of icon fonts and still appeals to teams that want GUI control over their icon workflow.
Compared to `svgs-to-icons`, IcoMoon requires more manual work and produces outputs — like icon fonts — that are generally considered less accessible and more difficult to style than mask-based SVGs. It does, however, offer a visual way to manage icon collections, which some designers and front-end developers still prefer.
—
### Font Design Tools
Tools ([Glyphs](https://glyphsapp.com/), [FontForge](https://fontforge.org/en-US/), [FontLab](https://www.fontlab.com/)) are professional font editors used to create traditional font files, including custom icon fonts. These are powerful tools, often used by type designers or branding teams to produce multi-purpose fonts that include both textual glyphs and iconography.
These tools operate at a different level of abstraction than `svgs-to-icons`. Rather than generating CSS classes or optimizing SVG files, they produce binary font files (`.woff`, `.ttf`) and require considerable expertise to use effectively. They’re appropriate for highly customized font workflows or typographic branding projects, but they’re not a practical option for everyday web icon usage.

## Contributing

Contributions are welcome! Please see [CONTRIBUTING](CONTRIBUTING.md).

## License

MIT License - see the [LICENSE](LICENSE) file for details.